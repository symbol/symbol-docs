############################
Integrating with an Exchange
############################

This document is intended to **guide developers** through the integration of the ``XYM`` token into an **Exchange platform**. It contains recommendations on how to set up accounts, listen for deposits, and create withdrawals as well as code examples ready to be adopted.

The code examples shared use the `Symbol SDK for TypeScript <https://github.com/symbol/symbol-sdk-typescript-javascript>`__, but can be ported to other :doc:`available SDKs <../../sdk>` since all of them share the same design principles. If there is no SDK supported for a required programming language, you may still be able to integrate by connecting directly via Symbol's :doc:`REST API <../../api>`.

Integration overview
********************

There are many ways to design an exchange. This guide is based on how to support ``XYM`` deposits and withdrawals in an exchange that follows a **central wallet approach**.

Please note that this design is not particularly recommend over others. However, its **simplified architecture** is a good showcase for Symbol's set of features involved in integrating with an Exchange. A different approach, for example, would be to use a different wallet for each user.

.. figure:: /resources/images/diagrams/exchange-integration-overview.png
   :align: center
   :width: 100%
   :target: /_images/exchange-integration-overview.png

   **Fig. 1**: General design diagram of the central wallet approach.

The main components of this architecture are described next.

Components
==========

Central wallet
--------------

The exchange owns a Symbol account where all the user's deposits and withdrawals occur. The keys to this account need to be on an online machine, so this is also commonly called the **Hot** wallet. This account only has the necessary amount of XYM for daily use (withdrawals and deposits), since it is the account most exposed to attacks.

Cold wallet
-----------

Cold wallet(s) hold a certain threshold for the pool of XYM. These accounts should be created and remain in a setup with no internet connection. Transactions issued from cold wallets must be signed offline and announced to the network using another device. It is advisable as well that cold wallets are set up with :doc:`multisig accounts <../../concepts/multisig-account>`.

Unique User ID
--------------

In the proposed architecture, each user is identified by a Unique User IDentifier (UUID) on the exchange's database. A user will deposit to the central wallet with their UUID attached as the :doc:`message <../../concepts/transfer-transaction>` of the transaction (called sometimes the **memo**). The UUID is only shown in the user's dashboard during the deposit confirmation.

One of the drawbacks of this design is that many users are not used to having a message attached to their transactions. If they forget to attach the UUID or attach a wrong UUID, it will lead to receiving lots of support tickets concerning "lost funds".

.. caution::

   Symbol's :doc:`Transfer transactions <../../concepts/transfer-transaction>` can hold an arbitrary message up to 1023 bytes long but **the first byte is treated specially by the** :doc:`Symbol SDK <../../sdk>`.

   This can be a source of confusion because the receiver of a transaction does not know if the message was generated by the Symbol SDK or otherwise (for example accessing the :doc:`REST gateway <../../api>`), so it does not know if the first byte must be treated specially or not.

   To avoid any issue, the following measures **must always be enforced**:

   - **Always** start messages with a byte in the 32 to 128 range (this is the standard ASCII printable range).
   - **Always** ignore any received initial byte outside the 32 to 128 range.

   Follow these rules, regardless of whether you use the Symbol SDK or not to generate and parse transfer transactions.

Exchange Server
---------------

This machine is constantly listening for user's withdraw requests, and monitors the blockchain to detect user deposits into the Exchange Central Wallet. As explained in the rest of this document, it maintains the database updated and announces any required transaction.

Exchange Database
-----------------

All the user's funds are merged together in the Exchange's wallets. This database keeps track of the amount of tokens each individual user holds. It also records all processed transactions, for record-keeping and to avoid processing the same transaction more than once.

Running a node
==============

Although not absolutely necessary, it is **recommended** that Exchanges deploy **their own Symbol node** to communicate with the rest of the network. Since each node automatically connects to **several other nodes** on the network, this approach is more robust than accessing the network always through the same public node, which **might become unavailable**.

If you are unable to run your own node, you can choose one from the list provided by the `Statistics Service <https://symbol.services/nodes>`__.

See the :doc:`different guides about deploying Symbol nodes <../network/index>` and make sure you create an :ref:`API node <api-node>`.

Accounts setup
==============

Exchanges can create the central and cold wallets by :doc:`downloading the official Symbol Desktop Wallet <../../wallets>` for **Windows**, **Linux** or **Mac**.

Every wallet has assigned an :doc:`account <../../concepts/account>` (a deposit box that holds tokens, which can only be transferred with the appropriate private key).

.. caution:: The **private key must be kept secret at all times** and must not be shared. Losing the private key means losing access to an account's funds, so make sure it is **securely backed up**.

It is advisable to turn central and cold wallets into :doc:`multisig accounts <../../concepts/multisig-account>` to add **two-factor authentication**. The cosignatories of the multisig account become the account managers, so no transaction can be announced from the multisig account without the cosignatories' approval. Symbol's current implementation of multisig is **“M-of-N”** meaning that *M* out of the total *N* cosignatories of an account need to approve a transaction for it to be announced.

.. caution:: Multisig accounts are a **powerful** yet **dangerous** tool. If access to some cosignatory account is lost and the minimum approval is not reached (the *M* above), access to the multisig account can be permanently lost. **Always configure multisig accounts with caution**.

To strengthen security, :doc:`extra account restrictions <../../concepts/account-restriction>` can be added to the Exchange's accounts, like blocking announcing or receiving transactions given a series of rules.

.. topic:: Related links

   - :doc:`Download the Symbol client <../../wallets>`.
   - :doc:`How to create a new account <../account/creating-an-account>`.
   - :doc:`How to turn an account into a multisig account <../multisig/creating-a-multisig-account>`.
   - :doc:`How to set account restrictions <../restriction/preventing-spam-attacks-with-account-restrictions>`.

The XYM token
=============

The native currency of the Symbol network is named ``XYM``. The token is used to pay for transactions and service :doc:`fees <../../concepts/fees>`, which are used as well to provide an incentive for those :doc:`participants <../../concepts/harvesting>` who secure the network and run the infrastructure.

Tokens can be divided up to ``divisibility`` decimal places. Amounts given without decimals are called **absolute**, whereas when decimals are used amounts are called **relative**. For example, when divisibility is 6, 1 relative token corresponds to 1'000'000 absolute tokens, and the smallest token is 0.000001 relative units. The smallest absolute unit is always 1, regardless of the divisibility.

These are the properties of ``XYM``:

.. csv-table::
   :header: "Property", "Value", "Description"
   :delim: ;
   :widths: 20 25 55

   ID; ``0x6BED913FA20223F8``; Token unique identifier
   Alias; ``symbol.xym``; Friendly name for the token
   Initial supply; 7'842'928'625 (relative); Initial amount of token units in circulation
   Max supply; 8'999'999'999 (relative); Maximum amount of token units in circulation after :doc:`inflation <../../concepts/inflation>` is applied
   Divisibility; 6; This means that the smallest fraction of the token is 0.000001 (relative).
   Duration; 0; Token does not expire
   Supply mutable; False; Token supply cannot be altered
   Transferable; True; Token can be transferred between arbitrary accounts
   Restrictable; False; Token creator cannot restrict which accounts can transact with the mosaic

.. caution::

   The ``XYM`` token can be referred to through its **native token ID** or its **friendlier alias** ``symbol.xym``, which has an ID on itself.

   On MAINNET, these IDs are ``0x6BED913FA20223F8`` (mosaic ID) and ``0xE74B99BA41F4AFEE`` (alias ID).

   **Always treat these two IDs as equivalent.**

.. _exchange-aggregate-transactions:

Aggregates
==========

Symbol has a novel feature called :ref:`aggregate-transaction` which allows bundling multiple inner transactions into a single one.

Therefore, when monitoring incoming **Transfer** transactions you must remember to also look inside all **Aggregate** transactions (Both **Aggregate Complete** and **Aggregate Bonded** transactions). The :ref:`example code given below <exchanges-monitoring>` shows a way of achieving this.

.. caution::

   When Aggregate transactions are **not** monitored, inner transfer transactions **are not detected**, leading to lots of **reports of lost funds**.

   This is specially relevant for :doc:`multi-signature accounts <../../concepts/multisig-account>`, where all transactions are wrapped in an Aggregate.

.. _exchange-avoid-rollbacks:

Avoiding rollbacks
==================

This is a **classic conflict** in blockchain technology: On one hand, if transactions are accepted too quickly, they might need to be **reverted** later on in the event of a :ref:`network fork <rollbacks>`. On the other hand, waiting for too long is **inconvenient** for users.

There are two ways of dealing with this in Symbol:

Using Finalization
------------------

Symbol implements :ref:`Finalization <finalization>`, a process that **guarantees** that blocks are **immutable** and therefore transactions are secure.

To know if a block has been finalized, check the ``latestFinalizedBlock`` property in the `/chain/info <https://symbol.github.io/symbol-openapi/v1.0.1/#operation/getChainInfo>`__ endpoint. All blocks with a **height** lower than (or equal to) ``latestFinalizedBlock.height`` are **finalized** and are therefore **immutable**.

**On average**, blocks are finalized after 5 minutes, in the absence of network problems.

Using a fixed wait
------------------

To have faster response times, one must ignore finalization and **accept the risk** that comes with this: **Unfinalized blocks have a probability of being reverted**, which decreases over time but is never zero until the block is finalized.

The procedure, which is common in blockchains which do not support finalization, is to **wait for a few blocks** to be validated (added to the blockchain) before accepting a transaction.

The amount of blocks to wait for depends on the risk one wants to accept. The recommendation for Symbol is **20 blocks** (about 10 minutes, regardless of network conditions, because Finalization will almost always happen during this time).

.. topic:: In summary

   - Waiting for a **fixed amount** of blocks leads to consistent confirmation times, but has the risk that confirmed transactions might be **reverted**.
   - Waiting for **finalization** has variable confirmation times (5 minutes on average) but has **zero rollback risk**.

Deadlines
---------

An added problem caused by rollbacks is that **transactions might expire** in the process of resolving a network fork.

A bit of context is required here. Transactions are not allowed to remain unconfirmed in the network forever, as this would pose a significant strain on the network's resources. Instead, **all transactions have a deadline**, and are automatically disposed of when the deadline arrives.

Users are free to use any deadline they want for their transactions, between now and 6h into the future (48h for :ref:`aggregate-bonded` transactions).

Transactions which are about to expire are delicate because, even if they get confirmed and are added to the blockchain, **a rollback could send them back to the unconfirmed state** and their deadline could expire before they are confirmed again.

.. topic:: Therefore, it is recommended that:

   - Incoming transactions with a deadline **less than 1h into the future** are rejected with a warning message, for example:

     ``Transaction is too close to expiration to be safely accepted.``

   - Exchanges avoid using transactions with short lifespans.

   - Exchanges actively encourage their customers to avoid using transactions with short lifespans.

The example code
================

This guide shows snippets of code to exemplify the different processes. All snippets are based on the same program that `can be found here <https://github.com/symbol/symbol-docs/tree/main/source/resources/examples/typescript/exchanges>`__. A few notes on this example program:

- It uses a fake ``DBService`` object that simulates the Exchange database. Calls to this object should obviously be replaced by the actual Exchange infrastructure in production code. For simplicity these calls are synchronous but they could be made asynchronously too.

- No error handling is performed at all. Use mechanisms like ``try {} catch`` where appropriate in production code.

- Finally, besides the snippets shown in the guide, the complete program also contains auxiliary code (like polling loops) in order to make it runnable and self-sufficient. This auxiliary code is not meant to be used as an inspiration at all, it is just there for convenience.

.. _exchange-deposits:

Deposits
********

.. figure:: /resources/images/diagrams/exchange-integration-deposit.png
   :align: center
   :width: 100%
   :target: /_images/exchange-integration-deposit.png

   **Fig. 2**: Deposit process.

Users perform deposits by announcing a regular transfer transaction using their wallet, moving the funds from their account directly to the Exchange Central Wallet. Since the transfer is handled entirely by the blockchain, the funds will be added to the Exchange Central Wallet without the Exchange's mediation, and this poses some problems:

- The **intended recipient** of the transaction must be determined. This is done by attaching the user's UUID as the transaction's message.
- The fact that a transaction has happened must be timely detected to update the user's account on the Exchange.
- Transactions must be **finalized** to be 100% sure that they will not be :ref:`rolled back <rollbacks>`.

The code proposed next addresses all these issues by monitoring the blockchain.

.. _exchanges-monitoring:

Monitoring
==========

The blockchain is polled periodically and all incoming transactions since last poll are processed in a batch:

1. All **Transfer** transactions added to the blockchain **since** the last check and **up to** the latest finalized block are examined, looking for the ones destined to the Central Exchange Wallet. This can be done efficiently with a single Symbol API call.

   - Transfer transactions embedded in **Aggregate Complete** and **Aggregate Bonded** transactions must also be examined (see the :ref:`exchange-aggregate-transactions` section above). This is handled in the example code by the ``embedded: true`` parameter in the `searchConfirmedTransactions <https://symbol.github.io/symbol-openapi/v1.0.4/#operation/searchConfirmedTransactions>`__ call.

   - If Finalization is not desired (see the :ref:`exchange-avoid-rollbacks` section above) you can search up to 20 blocks before the current chain height, for example.

2. Filter out transactions that:

   a. Have no message or the message does not correspond to an existing UUID.

   b. Do not contain tokens, or the token is not ``symbol.xym``.

   c. Have already been processed (as a security measure).

3. The remaining transactions are then processed:

   a. The tokens are added to the user's account in the database.

   b. The transaction is marked as processed by adding its hash to the database

4. Store the last height that has been processed and wait for the next polling period.

The code snippet, using `Symbol's TypeScript SDK <https://symbol.github.io/symbol-sdk-typescript-javascript/1.0.0/>`__ is this:

.. example-code::

    .. viewsource:: ../../resources/examples/typescript/exchanges/ProcessDeposits.ts
        :language: typescript
        :start-after:  /* start block processDeposits */
        :end-before: /* end block processDeposits */

    .. viewsource:: ../../resources/examples/typescript/exchanges/ProcessDeposits.js
        :language: javascript
        :start-after:  /* start block processDeposits */
        :end-before: /* end block processDeposits */

All configuration data is held in the ``ExchangeSymbolConfig`` object including the selection of the finalization mechanism.

The above code snippet should be called **in a loop** every minute, for example, and it will process **all new valid transactions** that have already been finalized (or that have waited enough blocks, depending on the chosen method).

However, **transactions will not be reported immediately**, and this might be annoying for users. Using :ref:`WebSockets <websockets>` transactions can be monitored in real-time and a notification can be shown to the user as soon as a transaction is **confirmed** on the network (or even as soon as it is **announced** on the network).

These transactions, though, should be clearly marked as **pending** and **not acted upon** until verified by the above code, to :ref:`avoid rollbacks <exchange-avoid-rollbacks>`.

.. topic:: Related links

   - :doc:`Transfer Transaction reference <../../concepts/transfer-transaction>`.
   - :doc:`Mosaic (token) reference <../../concepts/mosaic>`.
   - :doc:`Symbol API reference <../../api>`.
   - :ref:`WebSockets reference <websockets>`.

.. _exchange-withdrawals:

Withdrawals
***********

.. figure:: /resources/images/diagrams/exchange-integration-withdrawal.png
   :align: center
   :width: 100%
   :target: /_images/exchange-integration-withdrawal.png

   **Fig. 3**: Withdrawal process.

Users send withdrawal requests to the Exchange Server, via a web page or mobile app, for example. If the database indicates that the user has enough funds to perform the withdrawal, a :doc:`transfer transaction <../../concepts/transfer-transaction>` is announced from the Exchange Central Wallet to the Symbol address indicated in the request.

Announcing the transaction has a :doc:`fee <../../concepts/fees>`, which is paid by the Exchange Central Wallet but can be deduced from the user's account. Regardless of the token being transferred, fees are always paid in XYM tokens.

The withdrawal process requires two steps: First the transaction transferring the funds is **announced** and confirmed (added to the blockchain). Afterwards, the exchange needs to wait for the transaction to be **finalized**, as explained in the :ref:`exchange-avoid-rollbacks` section above.

Announcing
==========

The withdrawal transaction is just a regular Symbol :doc:`transfer transaction <../../concepts/transfer-transaction>`. The code looks long because it contains a lot of repeated boilerplate, to make it self-contained:

- Configuration is stored in the ``ExchangeSymbolConfig`` object.
- A number of repositories are instantiated via the ``RepositoryFactoryHttp`` class.
- The withdrawal details are retrieved from environment variables in this example.

Then:

1. The actual transaction is created using ``TransferTransaction.create``.
2. The transaction is signed.
3. The signed transaction is announced using the ``TransactionService`` to simplify waiting for its confirmation.

.. example-code::

    .. viewsource:: ../../resources/examples/typescript/exchanges/SendWithdrawal.ts
        :language: typescript
        :start-after:  /* start block sendWithdrawal */
        :end-before: /* end block sendWithdrawal */

    .. viewsource:: ../../resources/examples/typescript/exchanges/SendWithdrawal.js
        :language: javascript
        :start-after:  /* start block sendWithdrawal */
        :end-before: /* end block sendWithdrawal */

.. topic:: Multi-signature accounts

   When the Exchange Central Wallet is a :doc:`multi-signature account <../../concepts/multisig-account>` announcing the transaction is slightly more complex, as it involves the central wallet and its cosignatories. See the following resources:

   - :doc:`../aggregate/sending-a-multisig-transaction`.
   - :doc:`../aggregate/signing-announced-aggregate-bonded-transactions`.
   - :doc:`../aggregate/signing-announced-aggregate-bonded-transactions-automatically`.

Once the transaction is confirmed, the next step is to wait for it to be **finalized** to make sure it cannot be reverted. Until then, it should be marked as **pending** and **not acted upon**.

Finalization
============

Waiting for finalization is performed in a manner very similar to how incoming deposits are monitored (see :ref:`exchange-deposits` above): The blockchain is polled periodically and all transactions since the last check are processed in a batch, looking for outgoing transfers which have already been finalized.

The following code snippet should be run in a loop every minute, for example, and it will search for finalized withdrawal operations from the Exchange and record them in the Exchange's database.

This snippet can be run in the same loop as the deposits monitor :ref:`described above <exchange-deposits>`.

.. example-code::

    .. viewsource:: ../../resources/examples/typescript/exchanges/SendWithdrawal.ts
        :language: typescript
        :start-after:  /* start block pollWithdrawal */
        :end-before: /* end block pollWithdrawal */

    .. viewsource:: ../../resources/examples/typescript/exchanges/SendWithdrawal.js
        :language: javascript
        :start-after:  /* start block pollWithdrawal */
        :end-before: /* end block pollWithdrawal */

.. topic:: Related links

   - :doc:`Transaction life-cycle <../../concepts/transaction>`.
   - :doc:`Fees reference <../../concepts/fees>`.
   - :doc:`How to announce a transfer transaction programmatically <../transfer/sending-a-transfer-transaction>`.

Further information
*******************

Read the following pages for more information:

- :doc:`../blockchain/global-mosaic-supply`.